#pragma once

/**
 *  ========================================================
 *         THIS FILE IS AUTO-GENERATED BY REFLECT.PY
 *
 *     DO NOT MODIFY THIS FILE AS IT WILL BE RE-GENERATED
 *          PRIOR TO EACH BUILD IF YOU HAVE MADE ANY
 *            MODIFICATIONS TO THE ORIGINAL HEADER.
 *  ========================================================
 */
#include "test.gen.h"

namespace reflect {

    std::unique_ptr<Class<Test>> Class<Test>::s_instance = std::make_unique<Class<Test>>();

    std::vector<Field> Class<Test>::GetFields() const {
        return {
        };
    }

    std::vector<IMethod*> Class<Test>::GetMethods() const {
        return {
        };
    }

    std::unique_ptr<Class<Calyx::Base>> Class<Calyx::Base>::s_instance = std::make_unique<Class<Calyx::Base>>();

    std::vector<Field> Class<Calyx::Base>::GetFields() const {
        return {
            {
                offsetof(Calyx::Base, base),
                AccessSpecifier::PUBLIC,
                StorageType::INSTANCE,
                reflect::GetTypeId<int>(),
                "int",
                "base",
                {}
            },
            {
                offsetof(Calyx::Base, another_one),
                AccessSpecifier::PUBLIC,
                StorageType::INSTANCE,
                reflect::GetTypeId<int>(),
                "int",
                "another_one",
                {}
            },
            {
                (size_t)&Calyx::Base::yay,
                AccessSpecifier::PUBLIC,
                StorageType::STATIC,
                reflect::GetTypeId<const int>(),
                "const int",
                "yay",
                {}
            }
        };
    }

    std::vector<IMethod*> Class<Calyx::Base>::GetMethods() const {
        return {
        };
    }

    std::unique_ptr<Class<Calyx::Base::Inner>> Class<Calyx::Base::Inner>::s_instance = std::make_unique<Class<Calyx::Base::Inner>>();

    std::vector<Field> Class<Calyx::Base::Inner>::GetFields() const {
        return {
            {
                offsetof(Calyx::Base::Inner, pog),
                AccessSpecifier::PROTECTED,
                StorageType::INSTANCE,
                reflect::GetTypeId<std::string>(),
                "std::string",
                "pog",
                {}
            }
        };
    }

    std::vector<IMethod*> Class<Calyx::Base::Inner>::GetMethods() const {
        return {
        };
    }

    std::unique_ptr<Class<Calyx::Derived>> Class<Calyx::Derived>::s_instance = std::make_unique<Class<Calyx::Derived>>();

    std::vector<Field> Class<Calyx::Derived>::GetFields() const {
        return {
            {
                offsetof(Calyx::Derived, derived),
                AccessSpecifier::PUBLIC,
                StorageType::INSTANCE,
                reflect::GetTypeId<int>(),
                "int",
                "derived",
                {}
            }
        };
    }

    std::vector<IMethod*> Class<Calyx::Derived>::GetMethods() const {
        return {
        };
    }

    std::unique_ptr<Class<Calyx::Fields>> Class<Calyx::Fields>::s_instance = std::make_unique<Class<Calyx::Fields>>();

    std::vector<Field> Class<Calyx::Fields>::GetFields() const {
        return {
            {
                offsetof(Calyx::Fields, private_simple),
                AccessSpecifier::PRIVATE,
                StorageType::INSTANCE,
                reflect::GetTypeId<int>(),
                "int",
                "private_simple",
                {}
            },
            {
                offsetof(Calyx::Fields, private_constSimple),
                AccessSpecifier::PRIVATE,
                StorageType::INSTANCE,
                reflect::GetTypeId<const int>(),
                "const int",
                "private_constSimple",
                {}
            },
            {
                offsetof(Calyx::Fields, private_pointer),
                AccessSpecifier::PRIVATE,
                StorageType::INSTANCE,
                reflect::GetTypeId<int *>(),
                "int *",
                "private_pointer",
                {}
            },
            {
                offsetof(Calyx::Fields, private_complex),
                AccessSpecifier::PRIVATE,
                StorageType::INSTANCE,
                reflect::GetTypeId<std::string>(),
                "std::string",
                "private_complex",
                {}
            },
            {
                offsetof(Calyx::Fields, private_complexPointer),
                AccessSpecifier::PRIVATE,
                StorageType::INSTANCE,
                reflect::GetTypeId<Calyx::Base *>(),
                "Calyx::Base *",
                "private_complexPointer",
                {}
            },
            {
                offsetof(Calyx::Fields, private_constComplex),
                AccessSpecifier::PRIVATE,
                StorageType::INSTANCE,
                reflect::GetTypeId<const Calyx::Base>(),
                "const Calyx::Base",
                "private_constComplex",
                {}
            },
            {
                offsetof(Calyx::Fields, bing_bong),
                AccessSpecifier::PRIVATE,
                StorageType::INSTANCE,
                reflect::GetTypeId<int>(),
                "int",
                "bing_bong",
                {}
            },
            {
                offsetof(Calyx::Fields, protected_simple),
                AccessSpecifier::PROTECTED,
                StorageType::INSTANCE,
                reflect::GetTypeId<int>(),
                "int",
                "protected_simple",
                {}
            },
            {
                offsetof(Calyx::Fields, protected_constSimple),
                AccessSpecifier::PROTECTED,
                StorageType::INSTANCE,
                reflect::GetTypeId<const int>(),
                "const int",
                "protected_constSimple",
                {}
            },
            {
                offsetof(Calyx::Fields, protected_pointer),
                AccessSpecifier::PROTECTED,
                StorageType::INSTANCE,
                reflect::GetTypeId<int *>(),
                "int *",
                "protected_pointer",
                {}
            },
            {
                offsetof(Calyx::Fields, protected_complex),
                AccessSpecifier::PROTECTED,
                StorageType::INSTANCE,
                reflect::GetTypeId<Calyx::Base>(),
                "Calyx::Base",
                "protected_complex",
                {}
            },
            {
                offsetof(Calyx::Fields, protected_complexPointer),
                AccessSpecifier::PROTECTED,
                StorageType::INSTANCE,
                reflect::GetTypeId<Calyx::Base *>(),
                "Calyx::Base *",
                "protected_complexPointer",
                {}
            },
            {
                offsetof(Calyx::Fields, protected_constComplex),
                AccessSpecifier::PROTECTED,
                StorageType::INSTANCE,
                reflect::GetTypeId<const Calyx::Base>(),
                "const Calyx::Base",
                "protected_constComplex",
                {}
            },
            {
                offsetof(Calyx::Fields, public_simple),
                AccessSpecifier::PUBLIC,
                StorageType::INSTANCE,
                reflect::GetTypeId<int>(),
                "int",
                "public_simple",
                {}
            },
            {
                offsetof(Calyx::Fields, public_constSimple),
                AccessSpecifier::PUBLIC,
                StorageType::INSTANCE,
                reflect::GetTypeId<const int>(),
                "const int",
                "public_constSimple",
                {}
            },
            {
                offsetof(Calyx::Fields, public_pointer),
                AccessSpecifier::PUBLIC,
                StorageType::INSTANCE,
                reflect::GetTypeId<int *>(),
                "int *",
                "public_pointer",
                {}
            },
            {
                offsetof(Calyx::Fields, public_complex),
                AccessSpecifier::PUBLIC,
                StorageType::INSTANCE,
                reflect::GetTypeId<Calyx::Base>(),
                "Calyx::Base",
                "public_complex",
                {}
            },
            {
                offsetof(Calyx::Fields, public_complexPointer),
                AccessSpecifier::PUBLIC,
                StorageType::INSTANCE,
                reflect::GetTypeId<Calyx::Base *>(),
                "Calyx::Base *",
                "public_complexPointer",
                {}
            },
            {
                offsetof(Calyx::Fields, public_constComplex),
                AccessSpecifier::PUBLIC,
                StorageType::INSTANCE,
                reflect::GetTypeId<const Calyx::Base>(),
                "const Calyx::Base",
                "public_constComplex",
                {}
            },
            {
                offsetof(Calyx::Fields, public_annotated_simple),
                AccessSpecifier::PUBLIC,
                StorageType::INSTANCE,
                reflect::GetTypeId<int>(),
                "int",
                "public_annotated_simple",
                {}
            },
            {
                offsetof(Calyx::Fields, public_annotated_constSimple),
                AccessSpecifier::PUBLIC,
                StorageType::INSTANCE,
                reflect::GetTypeId<const int>(),
                "const int",
                "public_annotated_constSimple",
                {}
            },
            {
                offsetof(Calyx::Fields, public_annotated_pointer),
                AccessSpecifier::PUBLIC,
                StorageType::INSTANCE,
                reflect::GetTypeId<int *>(),
                "int *",
                "public_annotated_pointer",
                {}
            },
            {
                offsetof(Calyx::Fields, public_annotated_complex),
                AccessSpecifier::PUBLIC,
                StorageType::INSTANCE,
                reflect::GetTypeId<Calyx::Base>(),
                "Calyx::Base",
                "public_annotated_complex",
                {}
            },
            {
                offsetof(Calyx::Fields, public_annotated_complexPointer),
                AccessSpecifier::PUBLIC,
                StorageType::INSTANCE,
                reflect::GetTypeId<Calyx::Base *>(),
                "Calyx::Base *",
                "public_annotated_complexPointer",
                {}
            },
            {
                offsetof(Calyx::Fields, public_annotated_constComplex),
                AccessSpecifier::PUBLIC,
                StorageType::INSTANCE,
                reflect::GetTypeId<const Calyx::Base>(),
                "const Calyx::Base",
                "public_annotated_constComplex",
                {}
            }
        };
    }

    std::vector<IMethod*> Class<Calyx::Fields>::GetMethods() const {
        return {
        };
    }

    std::unique_ptr<Class<Calyx::Methods>> Class<Calyx::Methods>::s_instance = std::make_unique<Class<Calyx::Methods>>();

    std::vector<Field> Class<Calyx::Methods>::GetFields() const {
        return {
        };
    }

    std::vector<IMethod*> Class<Calyx::Methods>::GetMethods() const {
        return {
            Method<void (Calyx::Methods::*)(), &Calyx::Methods::private_void_void>::s_instance.get(),
            Method<void (Calyx::Methods::*)(), &Calyx::Methods::public_void_void>::s_instance.get(),
            Method<void (Calyx::Methods::*)(int), &Calyx::Methods::public_void_int>::s_instance.get(),
            Method<int (Calyx::Methods::*)(int), &Calyx::Methods::public_overload>::s_instance.get(),
            Method<int (Calyx::Methods::*)(int, int), &Calyx::Methods::public_overload>::s_instance.get(),
            Method<int (Calyx::Methods::*)(int, int, int), &Calyx::Methods::public_overload>::s_instance.get(),
            Method<void (*)(), &Calyx::Methods::public_static_void_void>::s_instance.get()
        };
    }

    std::unique_ptr<Method<void (Calyx::Methods::*)(), &Calyx::Methods::private_void_void>> Method<void (Calyx::Methods::*)(), &Calyx::Methods::private_void_void>::s_instance = std::make_unique<Method<void (Calyx::Methods::*)(), &Calyx::Methods::private_void_void>>();

    std::vector<Parameter> Method<void (Calyx::Methods::*)(), &Calyx::Methods::private_void_void>::GetParameterList() const {
        return {
        };
    }

    Object Method<void (Calyx::Methods::*)(), &Calyx::Methods::private_void_void>::Invoke(const Reference& o, const std::vector<Object>& args) const {
        auto params = GetParameterList();
        if (params.size() != args.size())
            throw Exception("Argument count does not match.");

        for (int i = 0; i < params.size(); i++) {
            if (params[i].typeID != args[i].GetTypeID())
                throw Exception("Argument types mismatch.");
        }

        o.GetT<Calyx::Methods>().private_void_void();
        return Object();
    }

    Object Method<void (Calyx::Methods::*)(), &Calyx::Methods::private_void_void>::Invoke(const std::vector<Object>& args) const {
        throw Exception("Instance method cannot be invoked statically.");
    }

    std::unique_ptr<Method<void (Calyx::Methods::*)(), &Calyx::Methods::public_void_void>> Method<void (Calyx::Methods::*)(), &Calyx::Methods::public_void_void>::s_instance = std::make_unique<Method<void (Calyx::Methods::*)(), &Calyx::Methods::public_void_void>>();

    std::vector<Parameter> Method<void (Calyx::Methods::*)(), &Calyx::Methods::public_void_void>::GetParameterList() const {
        return {
        };
    }

    Object Method<void (Calyx::Methods::*)(), &Calyx::Methods::public_void_void>::Invoke(const Reference& o, const std::vector<Object>& args) const {
        auto params = GetParameterList();
        if (params.size() != args.size())
            throw Exception("Argument count does not match.");

        for (int i = 0; i < params.size(); i++) {
            if (params[i].typeID != args[i].GetTypeID())
                throw Exception("Argument types mismatch.");
        }

        o.GetT<Calyx::Methods>().public_void_void();
        return Object();
    }

    Object Method<void (Calyx::Methods::*)(), &Calyx::Methods::public_void_void>::Invoke(const std::vector<Object>& args) const {
        throw Exception("Instance method cannot be invoked statically.");
    }

    std::unique_ptr<Method<void (Calyx::Methods::*)(int), &Calyx::Methods::public_void_int>> Method<void (Calyx::Methods::*)(int), &Calyx::Methods::public_void_int>::s_instance = std::make_unique<Method<void (Calyx::Methods::*)(int), &Calyx::Methods::public_void_int>>();

    std::vector<Parameter> Method<void (Calyx::Methods::*)(int), &Calyx::Methods::public_void_int>::GetParameterList() const {
        return {
            {
                reflect::GetTypeId<int>(),
                "int",
                "a"
            }
        };
    }

    Object Method<void (Calyx::Methods::*)(int), &Calyx::Methods::public_void_int>::Invoke(const Reference& o, const std::vector<Object>& args) const {
        auto params = GetParameterList();
        if (params.size() != args.size())
            throw Exception("Argument count does not match.");

        for (int i = 0; i < params.size(); i++) {
            if (params[i].typeID != args[i].GetTypeID())
                throw Exception("Argument types mismatch.");
        }

        o.GetT<Calyx::Methods>().public_void_int(args[0].GetT<std::decay_t<int>>());
        return Object();
    }

    Object Method<void (Calyx::Methods::*)(int), &Calyx::Methods::public_void_int>::Invoke(const std::vector<Object>& args) const {
        throw Exception("Instance method cannot be invoked statically.");
    }

    std::unique_ptr<Method<int (Calyx::Methods::*)(int), &Calyx::Methods::public_overload>> Method<int (Calyx::Methods::*)(int), &Calyx::Methods::public_overload>::s_instance = std::make_unique<Method<int (Calyx::Methods::*)(int), &Calyx::Methods::public_overload>>();

    std::vector<Parameter> Method<int (Calyx::Methods::*)(int), &Calyx::Methods::public_overload>::GetParameterList() const {
        return {
            {
                reflect::GetTypeId<int>(),
                "int",
                "a"
            }
        };
    }

    Object Method<int (Calyx::Methods::*)(int), &Calyx::Methods::public_overload>::Invoke(const Reference& o, const std::vector<Object>& args) const {
        auto params = GetParameterList();
        if (params.size() != args.size())
            throw Exception("Argument count does not match.");

        for (int i = 0; i < params.size(); i++) {
            if (params[i].typeID != args[i].GetTypeID())
                throw Exception("Argument types mismatch.");
        }

        return Object(o.GetT<Calyx::Methods>().public_overload(args[0].GetT<std::decay_t<int>>()));
    }

    Object Method<int (Calyx::Methods::*)(int), &Calyx::Methods::public_overload>::Invoke(const std::vector<Object>& args) const {
        throw Exception("Instance method cannot be invoked statically.");
    }

    std::unique_ptr<Method<int (Calyx::Methods::*)(int, int), &Calyx::Methods::public_overload>> Method<int (Calyx::Methods::*)(int, int), &Calyx::Methods::public_overload>::s_instance = std::make_unique<Method<int (Calyx::Methods::*)(int, int), &Calyx::Methods::public_overload>>();

    std::vector<Parameter> Method<int (Calyx::Methods::*)(int, int), &Calyx::Methods::public_overload>::GetParameterList() const {
        return {
            {
                reflect::GetTypeId<int>(),
                "int",
                "a"
            },
            {
                reflect::GetTypeId<int>(),
                "int",
                "b"
            }
        };
    }

    Object Method<int (Calyx::Methods::*)(int, int), &Calyx::Methods::public_overload>::Invoke(const Reference& o, const std::vector<Object>& args) const {
        auto params = GetParameterList();
        if (params.size() != args.size())
            throw Exception("Argument count does not match.");

        for (int i = 0; i < params.size(); i++) {
            if (params[i].typeID != args[i].GetTypeID())
                throw Exception("Argument types mismatch.");
        }

        return Object(o.GetT<Calyx::Methods>().public_overload(args[0].GetT<std::decay_t<int>>(), args[1].GetT<std::decay_t<int>>()));
    }

    Object Method<int (Calyx::Methods::*)(int, int), &Calyx::Methods::public_overload>::Invoke(const std::vector<Object>& args) const {
        throw Exception("Instance method cannot be invoked statically.");
    }

    std::unique_ptr<Method<int (Calyx::Methods::*)(int, int, int), &Calyx::Methods::public_overload>> Method<int (Calyx::Methods::*)(int, int, int), &Calyx::Methods::public_overload>::s_instance = std::make_unique<Method<int (Calyx::Methods::*)(int, int, int), &Calyx::Methods::public_overload>>();

    std::vector<Parameter> Method<int (Calyx::Methods::*)(int, int, int), &Calyx::Methods::public_overload>::GetParameterList() const {
        return {
            {
                reflect::GetTypeId<int>(),
                "int",
                "a"
            },
            {
                reflect::GetTypeId<int>(),
                "int",
                "b"
            },
            {
                reflect::GetTypeId<int>(),
                "int",
                "c"
            }
        };
    }

    Object Method<int (Calyx::Methods::*)(int, int, int), &Calyx::Methods::public_overload>::Invoke(const Reference& o, const std::vector<Object>& args) const {
        auto params = GetParameterList();
        if (params.size() != args.size())
            throw Exception("Argument count does not match.");

        for (int i = 0; i < params.size(); i++) {
            if (params[i].typeID != args[i].GetTypeID())
                throw Exception("Argument types mismatch.");
        }

        return Object(o.GetT<Calyx::Methods>().public_overload(args[0].GetT<std::decay_t<int>>(), args[1].GetT<std::decay_t<int>>(), args[2].GetT<std::decay_t<int>>()));
    }

    Object Method<int (Calyx::Methods::*)(int, int, int), &Calyx::Methods::public_overload>::Invoke(const std::vector<Object>& args) const {
        throw Exception("Instance method cannot be invoked statically.");
    }

    std::unique_ptr<Method<void (*)(), &Calyx::Methods::public_static_void_void>> Method<void (*)(), &Calyx::Methods::public_static_void_void>::s_instance = std::make_unique<Method<void (*)(), &Calyx::Methods::public_static_void_void>>();

    std::vector<Parameter> Method<void (*)(), &Calyx::Methods::public_static_void_void>::GetParameterList() const {
        return {
        };
    }

    Object Method<void (*)(), &Calyx::Methods::public_static_void_void>::Invoke(const std::vector<Object>& args) const {
        auto params = GetParameterList();
        if (params.size() != args.size())
            throw Exception("Argument count does not match.");

        for (int i = 0; i < params.size(); i++) {
            if (params[i].typeID != args[i].GetTypeID())
                throw Exception("Argument types mismatch.");
        }

        Calyx::Methods::public_static_void_void();
        return Object();
    }

    Object Method<void (*)(), &Calyx::Methods::public_static_void_void>::Invoke(const Reference& o, const std::vector<Object>& args) const {
        throw Exception("Static method cannot be invoked on an instance.");
    }

    std::unique_ptr<Class<Calyx::StaticMethods>> Class<Calyx::StaticMethods>::s_instance = std::make_unique<Class<Calyx::StaticMethods>>();

    std::vector<Field> Class<Calyx::StaticMethods>::GetFields() const {
        return {
        };
    }

    std::vector<IMethod*> Class<Calyx::StaticMethods>::GetMethods() const {
        return {
            Method<void (*)(), &Calyx::StaticMethods::private_void_void>::s_instance.get(),
            Method<int (*)(), &Calyx::StaticMethods::private_int_void>::s_instance.get(),
            Method<void (*)(), &Calyx::StaticMethods::public_void_void>::s_instance.get(),
            Method<int (*)(), &Calyx::StaticMethods::public_int_void>::s_instance.get()
        };
    }

    std::unique_ptr<Method<void (*)(), &Calyx::StaticMethods::private_void_void>> Method<void (*)(), &Calyx::StaticMethods::private_void_void>::s_instance = std::make_unique<Method<void (*)(), &Calyx::StaticMethods::private_void_void>>();

    std::vector<Parameter> Method<void (*)(), &Calyx::StaticMethods::private_void_void>::GetParameterList() const {
        return {
        };
    }

    Object Method<void (*)(), &Calyx::StaticMethods::private_void_void>::Invoke(const std::vector<Object>& args) const {
        auto params = GetParameterList();
        if (params.size() != args.size())
            throw Exception("Argument count does not match.");

        for (int i = 0; i < params.size(); i++) {
            if (params[i].typeID != args[i].GetTypeID())
                throw Exception("Argument types mismatch.");
        }

        Calyx::StaticMethods::private_void_void();
        return Object();
    }

    Object Method<void (*)(), &Calyx::StaticMethods::private_void_void>::Invoke(const Reference& o, const std::vector<Object>& args) const {
        throw Exception("Static method cannot be invoked on an instance.");
    }

    std::unique_ptr<Method<int (*)(), &Calyx::StaticMethods::private_int_void>> Method<int (*)(), &Calyx::StaticMethods::private_int_void>::s_instance = std::make_unique<Method<int (*)(), &Calyx::StaticMethods::private_int_void>>();

    std::vector<Parameter> Method<int (*)(), &Calyx::StaticMethods::private_int_void>::GetParameterList() const {
        return {
        };
    }

    Object Method<int (*)(), &Calyx::StaticMethods::private_int_void>::Invoke(const std::vector<Object>& args) const {
        auto params = GetParameterList();
        if (params.size() != args.size())
            throw Exception("Argument count does not match.");

        for (int i = 0; i < params.size(); i++) {
            if (params[i].typeID != args[i].GetTypeID())
                throw Exception("Argument types mismatch.");
        }

        return Object(Calyx::StaticMethods::private_int_void());
    }

    Object Method<int (*)(), &Calyx::StaticMethods::private_int_void>::Invoke(const Reference& o, const std::vector<Object>& args) const {
        throw Exception("Static method cannot be invoked on an instance.");
    }

    std::unique_ptr<Method<void (*)(), &Calyx::StaticMethods::public_void_void>> Method<void (*)(), &Calyx::StaticMethods::public_void_void>::s_instance = std::make_unique<Method<void (*)(), &Calyx::StaticMethods::public_void_void>>();

    std::vector<Parameter> Method<void (*)(), &Calyx::StaticMethods::public_void_void>::GetParameterList() const {
        return {
        };
    }

    Object Method<void (*)(), &Calyx::StaticMethods::public_void_void>::Invoke(const std::vector<Object>& args) const {
        auto params = GetParameterList();
        if (params.size() != args.size())
            throw Exception("Argument count does not match.");

        for (int i = 0; i < params.size(); i++) {
            if (params[i].typeID != args[i].GetTypeID())
                throw Exception("Argument types mismatch.");
        }

        Calyx::StaticMethods::public_void_void();
        return Object();
    }

    Object Method<void (*)(), &Calyx::StaticMethods::public_void_void>::Invoke(const Reference& o, const std::vector<Object>& args) const {
        throw Exception("Static method cannot be invoked on an instance.");
    }

    std::unique_ptr<Method<int (*)(), &Calyx::StaticMethods::public_int_void>> Method<int (*)(), &Calyx::StaticMethods::public_int_void>::s_instance = std::make_unique<Method<int (*)(), &Calyx::StaticMethods::public_int_void>>();

    std::vector<Parameter> Method<int (*)(), &Calyx::StaticMethods::public_int_void>::GetParameterList() const {
        return {
        };
    }

    Object Method<int (*)(), &Calyx::StaticMethods::public_int_void>::Invoke(const std::vector<Object>& args) const {
        auto params = GetParameterList();
        if (params.size() != args.size())
            throw Exception("Argument count does not match.");

        for (int i = 0; i < params.size(); i++) {
            if (params[i].typeID != args[i].GetTypeID())
                throw Exception("Argument types mismatch.");
        }

        return Object(Calyx::StaticMethods::public_int_void());
    }

    Object Method<int (*)(), &Calyx::StaticMethods::public_int_void>::Invoke(const Reference& o, const std::vector<Object>& args) const {
        throw Exception("Static method cannot be invoked on an instance.");
    }

}
