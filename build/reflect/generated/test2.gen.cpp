
/**
 *  ========================================================
 *         THIS FILE IS AUTO-GENERATED BY REFLECT.PY
 * 
 *     DO NOT MODIFY THIS FILE AS IT WILL BE RE-GENERATED
 *          PRIOR TO EACH BUILD IF YOU HAVE MADE ANY 
 *            MODIFICATIONS TO THE ORIGINAL HEADER.
 *  ========================================================
 */          
            
#include "test2.gen.h"

namespace reflect {

    std::unique_ptr<Enum<Calyx::AnotherEnum>> Enum<Calyx::AnotherEnum>::s_instance = std::make_unique<Enum<Calyx::AnotherEnum>>();
    
    std::unordered_map<std::string, int> Enum<Calyx::AnotherEnum>::s_enumValues = { 
        { "A", 0 },
        { "B", 1 },
        { "C", 2 },
        { "D", 3 },
        { "Z", 25 } 
    };
    
    std::vector<std::string> Enum<Calyx::AnotherEnum>::GetStringValues() const {
        return { 
            "A",
            "B",
            "C",
            "D",
            "Z"
        };
    }
    
    std::vector<int> Enum<Calyx::AnotherEnum>::GetIntValues() const {
        return { 
            0,
            1,
            2,
            3,
            25 
        };
    }

    bool Enum<Calyx::AnotherEnum>::Translate(const std::string& value, int& out) const {
        for (auto& it : s_enumValues) {
            if (it.first == value) {
                out = it.second;
                return true;
            }
        }
        return false;
    }
    
    bool Enum<Calyx::AnotherEnum>::Translate(int value, std::string& out) const {
       for (auto& it : s_enumValues) {
            if (it.second == value) {
                out = it.first;
                return true;
            }
        }
        return false;
    }
    
    std::unique_ptr<Class<Calyx::Test>> Class<Calyx::Test>::s_instance = std::make_unique<Class<Calyx::Test>>();
    
    std::vector<Field> Class<Calyx::Test>::GetFields() const {
        return {
            {
                offsetof(Calyx::Test, a),
                AccessSpecifier::PUBLIC, 
                StorageType::INSTANCE, 
                reflect::GetTypeId<int>(),
                "int", 
                "a",
                {
                    
                }
            },
            {
                offsetof(Calyx::Test, b),
                AccessSpecifier::PUBLIC, 
                StorageType::INSTANCE, 
                reflect::GetTypeId<int>(),
                "int", 
                "b",
                {
                    
                }
            },
            {
                offsetof(Calyx::Test, c),
                AccessSpecifier::PUBLIC, 
                StorageType::INSTANCE, 
                reflect::GetTypeId<char>(),
                "char", 
                "c",
                {
                    
                }
            },
        };
    }
    
    std::vector<IMethod*> Class<Calyx::Test>::GetMethods() const {
        return {
            Method<void (Calyx::Test::*)(), &Calyx::Test::test>::s_instance.get(),
        };
    }
    
    
    std::unique_ptr<Method<void (Calyx::Test::*)(), &Calyx::Test::test>> Method<void (Calyx::Test::*)(), &Calyx::Test::test>::s_instance = std::make_unique<Method<void (Calyx::Test::*)(), &Calyx::Test::test>>();
    
    std::vector<Parameter> Method<void (Calyx::Test::*)(), &Calyx::Test::test>::GetParameterList() const {
        return {
          
        };
    }
    
    Object Method<void (Calyx::Test::*)(), &Calyx::Test::test>::Invoke(const std::vector<Object>& args) const {
        throw Exception("Instance method cannot be invoked statically!");
    }
    
    Object Method<void (Calyx::Test::*)(), &Calyx::Test::test>::Invoke(const Reference& o, const std::vector<Object>& args) const {
        auto params = GetParameterList();
        if (params.size() != args.size())
            throw Exception("Argument count does not match!");
            
        for (int i = 0; i < params.size(); i++) {
            if (params[i].typeID != args[i].GetTypeID())
                throw Exception("Arguments type mismatch!");
        }
        
        o.GetT<Calyx::Test>().test();
        return Object();
    }

    
}