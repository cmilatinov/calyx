#pragma once

/**
 *  ========================================================
 *         THIS FILE IS AUTO-GENERATED BY REFLECT.PY
 * 
 *     DO NOT MODIFY THIS FILE AS IT WILL BE RE-GENERATED
 *          PRIOR TO EACH BUILD IF YOU HAVE MADE ANY 
 *            MODIFICATIONS TO THE ORIGINAL HEADER.
 *  ========================================================
 */

#include "test.h"

namespace reflect {

    template<>
    class Enum<Calyx::Enum> : public IEnum {
    
    private:
        static std::unordered_map<std::string, int> s_enumValues;
    
    public:
        static std::unique_ptr<Enum<Calyx::Enum>> s_instance;
    
        std::string GetName() const override { return "Enum"; }
        std::string GetFullName() const override { return "Calyx::Enum"; }
        int GetTypeID() const override { return reflect::GetTypeId<Calyx::Enum>(); }
        
        std::unordered_map<std::string, int> GetEnumValues() const override { return s_enumValues; }
        
        std::vector<std::string> GetStringValues() const override;
        std::vector<int> GetIntValues() const override;

        bool Translate(const std::string& value, int& out) const override;
        bool Translate(int value, std::string& out) const override;
        
    };
    
    template<>
    class Class<Calyx::Base> : public IClass {
    
    public:
        static std::unique_ptr<Class<Calyx::Base>> s_instance;
    
        std::string GetName() const override { return "Base"; }
        std::string GetFullName() const override { return "Calyx::Base"; }
        int GetTypeID() const override { return reflect::GetTypeId<Calyx::Base>(); }
        
        std::vector<Field> GetFields() const override;
        std::vector<IMethod*> GetMethods() const override;
        
    };
    
    template<>
    class Class<Calyx::Derived> : public IClass {
    
    public:
        static std::unique_ptr<Class<Calyx::Derived>> s_instance;
    
        std::string GetName() const override { return "Derived"; }
        std::string GetFullName() const override { return "Calyx::Derived"; }
        int GetTypeID() const override { return reflect::GetTypeId<Calyx::Derived>(); }
        
        std::vector<Field> GetFields() const override;
        std::vector<IMethod*> GetMethods() const override;
        
    };
    
    template<>
    class Class<Calyx::Fields> : public IClass {
    
    public:
        static std::unique_ptr<Class<Calyx::Fields>> s_instance;
    
        std::string GetName() const override { return "Fields"; }
        std::string GetFullName() const override { return "Calyx::Fields"; }
        int GetTypeID() const override { return reflect::GetTypeId<Calyx::Fields>(); }
        
        std::vector<Field> GetFields() const override;
        std::vector<IMethod*> GetMethods() const override;
        
    };
    
    template<>
    class Class<Calyx::Methods> : public IClass {
    
    public:
        static std::unique_ptr<Class<Calyx::Methods>> s_instance;
    
        std::string GetName() const override { return "Methods"; }
        std::string GetFullName() const override { return "Calyx::Methods"; }
        int GetTypeID() const override { return reflect::GetTypeId<Calyx::Methods>(); }
        
        std::vector<Field> GetFields() const override;
        std::vector<IMethod*> GetMethods() const override;
        
    };
    
    template<>
    class Method<void (Calyx::Methods::*)(), &Calyx::Methods::private_void_void> : public IMethod {
    
    public:
        static std::unique_ptr<Method<void (Calyx::Methods::*)(), &Calyx::Methods::private_void_void>> s_instance;
    
        std::string GetName() const override { return "private_void_void"; }
        std::string GetFullName() const override { return "Calyx::Methods::private_void_void"; }
        int GetTypeID() const override { return reflect::GetTypeId<void (Calyx::Methods::*)()>(); }
        
        ReturnType GetReturnType() const override { return { reflect::GetTypeId<void>(), "void" }; }
        std::vector<Parameter> GetParameterList() const override;
        
        AccessSpecifier GetAccessSpecifier() const override { return AccessSpecifier::PRIVATE; }
        StorageType GetStorageType() const override { return StorageType::INSTANCE; }
        
        Object Invoke(const std::vector<Object>& args) const override;
        Object Invoke(const Reference& o, const std::vector<Object>& args) const override;
        
    };

    template<>
    class Method<void (Calyx::Methods::*)(), &Calyx::Methods::public_void_void> : public IMethod {
    
    public:
        static std::unique_ptr<Method<void (Calyx::Methods::*)(), &Calyx::Methods::public_void_void>> s_instance;
    
        std::string GetName() const override { return "public_void_void"; }
        std::string GetFullName() const override { return "Calyx::Methods::public_void_void"; }
        int GetTypeID() const override { return reflect::GetTypeId<void (Calyx::Methods::*)()>(); }
        
        ReturnType GetReturnType() const override { return { reflect::GetTypeId<void>(), "void" }; }
        std::vector<Parameter> GetParameterList() const override;
        
        AccessSpecifier GetAccessSpecifier() const override { return AccessSpecifier::PUBLIC; }
        StorageType GetStorageType() const override { return StorageType::INSTANCE; }
        
        Object Invoke(const std::vector<Object>& args) const override;
        Object Invoke(const Reference& o, const std::vector<Object>& args) const override;
        
    };

    template<>
    class Method<void (Calyx::Methods::*)(int), &Calyx::Methods::public_void_int> : public IMethod {
    
    public:
        static std::unique_ptr<Method<void (Calyx::Methods::*)(int), &Calyx::Methods::public_void_int>> s_instance;
    
        std::string GetName() const override { return "public_void_int"; }
        std::string GetFullName() const override { return "Calyx::Methods::public_void_int"; }
        int GetTypeID() const override { return reflect::GetTypeId<void (Calyx::Methods::*)(int)>(); }
        
        ReturnType GetReturnType() const override { return { reflect::GetTypeId<void>(), "void" }; }
        std::vector<Parameter> GetParameterList() const override;
        
        AccessSpecifier GetAccessSpecifier() const override { return AccessSpecifier::PUBLIC; }
        StorageType GetStorageType() const override { return StorageType::INSTANCE; }
        
        Object Invoke(const std::vector<Object>& args) const override;
        Object Invoke(const Reference& o, const std::vector<Object>& args) const override;
        
    };

    template<>
    class Method<int (Calyx::Methods::*)(int), &Calyx::Methods::public_overload> : public IMethod {
    
    public:
        static std::unique_ptr<Method<int (Calyx::Methods::*)(int), &Calyx::Methods::public_overload>> s_instance;
    
        std::string GetName() const override { return "public_overload"; }
        std::string GetFullName() const override { return "Calyx::Methods::public_overload"; }
        int GetTypeID() const override { return reflect::GetTypeId<int (Calyx::Methods::*)(int)>(); }
        
        ReturnType GetReturnType() const override { return { reflect::GetTypeId<int>(), "int" }; }
        std::vector<Parameter> GetParameterList() const override;
        
        AccessSpecifier GetAccessSpecifier() const override { return AccessSpecifier::PUBLIC; }
        StorageType GetStorageType() const override { return StorageType::INSTANCE; }
        
        Object Invoke(const std::vector<Object>& args) const override;
        Object Invoke(const Reference& o, const std::vector<Object>& args) const override;
        
    };

    template<>
    class Method<int (Calyx::Methods::*)(int, int), &Calyx::Methods::public_overload> : public IMethod {
    
    public:
        static std::unique_ptr<Method<int (Calyx::Methods::*)(int, int), &Calyx::Methods::public_overload>> s_instance;
    
        std::string GetName() const override { return "public_overload"; }
        std::string GetFullName() const override { return "Calyx::Methods::public_overload"; }
        int GetTypeID() const override { return reflect::GetTypeId<int (Calyx::Methods::*)(int, int)>(); }
        
        ReturnType GetReturnType() const override { return { reflect::GetTypeId<int>(), "int" }; }
        std::vector<Parameter> GetParameterList() const override;
        
        AccessSpecifier GetAccessSpecifier() const override { return AccessSpecifier::PUBLIC; }
        StorageType GetStorageType() const override { return StorageType::INSTANCE; }
        
        Object Invoke(const std::vector<Object>& args) const override;
        Object Invoke(const Reference& o, const std::vector<Object>& args) const override;
        
    };

    template<>
    class Method<int (Calyx::Methods::*)(int, int, int), &Calyx::Methods::public_overload> : public IMethod {
    
    public:
        static std::unique_ptr<Method<int (Calyx::Methods::*)(int, int, int), &Calyx::Methods::public_overload>> s_instance;
    
        std::string GetName() const override { return "public_overload"; }
        std::string GetFullName() const override { return "Calyx::Methods::public_overload"; }
        int GetTypeID() const override { return reflect::GetTypeId<int (Calyx::Methods::*)(int, int, int)>(); }
        
        ReturnType GetReturnType() const override { return { reflect::GetTypeId<int>(), "int" }; }
        std::vector<Parameter> GetParameterList() const override;
        
        AccessSpecifier GetAccessSpecifier() const override { return AccessSpecifier::PUBLIC; }
        StorageType GetStorageType() const override { return StorageType::INSTANCE; }
        
        Object Invoke(const std::vector<Object>& args) const override;
        Object Invoke(const Reference& o, const std::vector<Object>& args) const override;
        
    };

    template<>
    class Method<void (*)(), &Calyx::Methods::public_static_void_void> : public IMethod {
    
    public:
        static std::unique_ptr<Method<void (*)(), &Calyx::Methods::public_static_void_void>> s_instance;
    
        std::string GetName() const override { return "public_static_void_void"; }
        std::string GetFullName() const override { return "Calyx::Methods::public_static_void_void"; }
        int GetTypeID() const override { return reflect::GetTypeId<void (*)()>(); }
        
        ReturnType GetReturnType() const override { return { reflect::GetTypeId<void>(), "void" }; }
        std::vector<Parameter> GetParameterList() const override;
        
        AccessSpecifier GetAccessSpecifier() const override { return AccessSpecifier::PUBLIC; }
        StorageType GetStorageType() const override { return StorageType::STATIC; }
        
        Object Invoke(const std::vector<Object>& args) const override;
        Object Invoke(const Reference& o, const std::vector<Object>& args) const override;
        
    };
    template<>
    class Class<Calyx::StaticMethods> : public IClass {
    
    public:
        static std::unique_ptr<Class<Calyx::StaticMethods>> s_instance;
    
        std::string GetName() const override { return "StaticMethods"; }
        std::string GetFullName() const override { return "Calyx::StaticMethods"; }
        int GetTypeID() const override { return reflect::GetTypeId<Calyx::StaticMethods>(); }
        
        std::vector<Field> GetFields() const override;
        std::vector<IMethod*> GetMethods() const override;
        
    };
    
    template<>
    class Method<void (*)(), &Calyx::StaticMethods::private_void_void> : public IMethod {
    
    public:
        static std::unique_ptr<Method<void (*)(), &Calyx::StaticMethods::private_void_void>> s_instance;
    
        std::string GetName() const override { return "private_void_void"; }
        std::string GetFullName() const override { return "Calyx::StaticMethods::private_void_void"; }
        int GetTypeID() const override { return reflect::GetTypeId<void (*)()>(); }
        
        ReturnType GetReturnType() const override { return { reflect::GetTypeId<void>(), "void" }; }
        std::vector<Parameter> GetParameterList() const override;
        
        AccessSpecifier GetAccessSpecifier() const override { return AccessSpecifier::PRIVATE; }
        StorageType GetStorageType() const override { return StorageType::STATIC; }
        
        Object Invoke(const std::vector<Object>& args) const override;
        Object Invoke(const Reference& o, const std::vector<Object>& args) const override;
        
    };

    template<>
    class Method<int (*)(), &Calyx::StaticMethods::private_int_void> : public IMethod {
    
    public:
        static std::unique_ptr<Method<int (*)(), &Calyx::StaticMethods::private_int_void>> s_instance;
    
        std::string GetName() const override { return "private_int_void"; }
        std::string GetFullName() const override { return "Calyx::StaticMethods::private_int_void"; }
        int GetTypeID() const override { return reflect::GetTypeId<int (*)()>(); }
        
        ReturnType GetReturnType() const override { return { reflect::GetTypeId<int>(), "int" }; }
        std::vector<Parameter> GetParameterList() const override;
        
        AccessSpecifier GetAccessSpecifier() const override { return AccessSpecifier::PRIVATE; }
        StorageType GetStorageType() const override { return StorageType::STATIC; }
        
        Object Invoke(const std::vector<Object>& args) const override;
        Object Invoke(const Reference& o, const std::vector<Object>& args) const override;
        
    };

    template<>
    class Method<void (*)(), &Calyx::StaticMethods::public_void_void> : public IMethod {
    
    public:
        static std::unique_ptr<Method<void (*)(), &Calyx::StaticMethods::public_void_void>> s_instance;
    
        std::string GetName() const override { return "public_void_void"; }
        std::string GetFullName() const override { return "Calyx::StaticMethods::public_void_void"; }
        int GetTypeID() const override { return reflect::GetTypeId<void (*)()>(); }
        
        ReturnType GetReturnType() const override { return { reflect::GetTypeId<void>(), "void" }; }
        std::vector<Parameter> GetParameterList() const override;
        
        AccessSpecifier GetAccessSpecifier() const override { return AccessSpecifier::PUBLIC; }
        StorageType GetStorageType() const override { return StorageType::STATIC; }
        
        Object Invoke(const std::vector<Object>& args) const override;
        Object Invoke(const Reference& o, const std::vector<Object>& args) const override;
        
    };

    template<>
    class Method<int (*)(), &Calyx::StaticMethods::public_int_void> : public IMethod {
    
    public:
        static std::unique_ptr<Method<int (*)(), &Calyx::StaticMethods::public_int_void>> s_instance;
    
        std::string GetName() const override { return "public_int_void"; }
        std::string GetFullName() const override { return "Calyx::StaticMethods::public_int_void"; }
        int GetTypeID() const override { return reflect::GetTypeId<int (*)()>(); }
        
        ReturnType GetReturnType() const override { return { reflect::GetTypeId<int>(), "int" }; }
        std::vector<Parameter> GetParameterList() const override;
        
        AccessSpecifier GetAccessSpecifier() const override { return AccessSpecifier::PUBLIC; }
        StorageType GetStorageType() const override { return StorageType::STATIC; }
        
        Object Invoke(const std::vector<Object>& args) const override;
        Object Invoke(const Reference& o, const std::vector<Object>& args) const override;
        
    };
}