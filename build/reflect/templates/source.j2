#pragma once

## include "comment"

#include "{{ generatedHeader }}"

namespace reflect {

## for class in classes
## set typename = "Class<" + class.fullName + ">"
    std::unique_ptr<{{typename}}> {{typename}}::s_instance = std::make_unique<{{typename}}>();

    std::vector<Field> {{typename}}::GetFields() const {
        return {
## for field in class.fields
            {
                {{ field.offset }},
                {{ field.access }},
                {{ field.storageType }},
                reflect::GetTypeId<{{ field.type }}>(),
                "{{ field.type }}",
                "{{ field.name }}",
                {}
            }{% if not loop.is_last %},{% endif %}
## endfor
        };
    }

    std::vector<IMethod*> {{typename}}::GetMethods() const {
        return {
## for method in class.methods
## set methodType = "Method<" + method.pointerType + ", &" + method.fullName + ">"
            {{ methodType }}::s_instance.get(){% if not loop.is_last %},{% endif %}
## endfor
        };
    }

## for method in class.methods
## set methodType = "Method<" + method.pointerType + ", &" + method.fullName + ">"
    std::unique_ptr<{{ methodType }}> {{ methodType }}::s_instance = std::make_unique<{{ methodType }}>();

    std::vector<Parameter> {{ methodType }}::GetParameterList() const {
        return {
## for parameter in method.parameters
            {
                reflect::GetTypeId<{{ parameter.type }}>(),
                "{{ parameter.type }}",
                "{{ parameter.name }}"
            }{% if not loop.is_last %},{% endif %}
## endfor
        };
    }

## if method.isStatic
    Object {{ methodType }}::Invoke(const std::vector<Object>& args) const {
        auto params = GetParameterList();
        if (params.size() != args.size())
            throw Exception("Argument count does not match.");

        for (int i = 0; i < params.size(); i++) {
            if (params[i].typeID != args[i].GetTypeID())
                throw Exception("Argument types mismatch.");
        }

## if method.isVoidReturn
        {{ method.invocation }};
        return Object();
## else
        return Object({{ method.invocation }});
## endif
    }

    Object {{ methodType }}::Invoke(const Reference& o, const std::vector<Object>& args) const {
        throw Exception("Static method cannot be invoked on an instance.");
    }
## else
    Object {{ methodType }}::Invoke(const Reference& o, const std::vector<Object>& args) const {
        auto params = GetParameterList();
        if (params.size() != args.size())
            throw Exception("Argument count does not match.");

        for (int i = 0; i < params.size(); i++) {
            if (params[i].typeID != args[i].GetTypeID())
                throw Exception("Argument types mismatch.");
        }

## if method.isVoidReturn
        {{ method.invocation }};
        return Object();
## else
        return Object({{ method.invocation }});
## endif
    }

    Object {{ methodType }}::Invoke(const std::vector<Object>& args) const {
        throw Exception("Instance method cannot be invoked statically.");
    }
## endif

## endfor
## endfor
}
